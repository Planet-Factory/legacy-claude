\section{Planar Approximation}
It is time to deal with the pole situation. The north and south poles that is, not the lovely people over in Poland. We run into problems because the latitude longitude grid cells become to small 
near the poles. Therefore, the magnitudes no longer fit into one cell and overflow into other cells which makes everything kind of funky. So we need to fix that, and we do that by a planar 
approximation. 

\subsection{The Initial Theory}
As said earlier, the grid cells on the latitude longitude grid get closer together the closer you get to the poles which poses problems. To fix this, we will be using a planar approximation of 
the poles. What this means is that we will map the 3D grid near the poles onto a 2D plane parallel to the poles, as if we put a giant flat plane in the exact center of the poles and draw lines
from the grid directly upwards to the plane. For a visual representation, please consult the stream with timestamp 1:38:25 \cite{polarPlane}, which includes some explanation. In the streamm we
use $r$ to indicate the radius of the planet (which we assume is a sphere), $\theta$ for the longitude and $\lambda$ for the latitude. So we have spherical coordinates, which we need to transform
into $x$ and $y$ coordinates on the plane. We also need the distance between the center point (the point where the plane touches the planet which is the center of the pole) and the projected 
point on the plane from the grid (the location on the plane where a line from the gird upwards to the plane hits it). This distance is denoted by $a$ (Simon chose this one, not me). We then get 
the following equations as shown in \autoref{eq:polar distance}, \autoref{eq:polar x} and \autoref{eq:polar y}. 

\begin{subequations}
    \begin{equation}
        \label{eq:polar distance}
        a = r \cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar x}
        x = a \sin(\lambda)
    \end{equation}
    \begin{equation}
        \label{eq:polar y}
        y = a \cos(\lambda)
    \end{equation}
\end{subequations}

But what if we know $x$ and $y$ and want to know $\theta$ and $\lambda$? Pythagoras' Theorem then comes into play \cite{pythagoras}. We know that (due to Pythagoras) \autoref{eq:pythagoras} must 
always be true. Then if we substitue $a$ by $\sqrt{x^2 + y^2}$ in \autoref{eq:polar distance} we get \autoref{eq:polar theta1}. Then we transform that equation such that we only have $\theta$ on 
one side and the rest on the other side (since we want to know $\theta$) and we get \autoref{eq:polar theta3}.
\begin{equation}
    \label{eq:pythagoras}
    x^2 + y^2 = a^2
\end{equation}

\begin{subequations}
    \begin{equation}
        \label{eq:polar theta1}
        \sqrt{x^2 + y^2} = r\cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar theta2}
        \frac{\sqrt{x^2 + y^2}}{r} = \cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar theta3}
        \arccos(\frac{\sqrt{x^2 + y^2}}{r}) = \theta
    \end{equation}
\end{subequations}

For $\lambda$ we need another trigonometric function which is the tangent ($\tan$). The tangent is defined in \autoref{eq:tan}. If we then take a look at \autoref{eq:polar x} and 
\autoref{eq:polar y}, we see that $\lambda$ is present in both equations. So we need to use both to get $\lambda$ \footnote{Yes you could only use one but since we both know $x$ and $y$ it is a
bit easier to use both than to only use one as you need to know $\theta$ at that point as well which may or may not be the case.}. So let's combine \autoref{eq:polar x} and \autoref{eq:polar y}
in \autoref{eq:polar lambda1}, transform it such that we end up with only $\lambda$ on one side and the rest on the other side and we end up with \autoref{eq:polar lambda3}.

\begin{equation}
    \label{eq:tan}
    \tan(\alpha) = \frac{\sin(\alpha)}{\cos(\alpha)}
\end{equation}

\begin{subequations}
    \begin{equation}
        \label{eq:polar lambda1}
        \frac{x}{y} = \frac{a\sin(\lambda)}{a\cos(\lambda)} = \frac{\sin(\lambda)}{\cos(\lambda)}
    \end{equation}
    \begin{equation}
        \label{eq:polar lambda2}
        \frac{x}{y} = \tan(\lambda)
    \end{equation}
    \begin{equation}
        \label{eq:polar lambda3}
        \lambda = \arctan(\frac{x}{y})
    \end{equation}
\end{subequations}

\subsection{The Grid Code}
To start the planar approximation, we first need to create a grid. One for the north pole, and one for the south pole. Now since the project is made in Python, Simon uses a function to generate 
a grid from two coordinate vectors (lists with a coordinate as elements). Since the documentation tries to not be language specific, I instead opt to use words instead of function calls. What 
that comes down to is use your favourite language and import the libraries that do this for you, or start coding your own after finding out how to do that (your mileage may vary). To implement 
the grid function in the exact same way as the numpy packages does, please refer to the following two references \cite{meshgridDoc} \cite{meshgridGFG}. Anyway, the code for the grid can be found 
in \autoref{alg:polar grid south}. To convert $x, y$ coordinates into $lat, lon$ coordinates, we make use of \autoref{eq:polar theta3} and \autoref{eq:polar lambda3}. Keep in mind that the 
equations themselves assume that the angles are in radians, whereas the model uses the angles in degrees so they need to be converted. To convert from $lat, lon$ back into $x, y$ we need to 
combine \autoref{eq:polar distance}, \autoref{eq:polar x} and \autoref{eq:polar y}.

\begin{algorithm}[htb]
    \caption{Generating the grid for polar approximation of the south pole}
    \label{alg:polar grid south}
    \SetKwComment{Comment}{//}{}
    $poleLowIndexS \leftarrow $ find first index where $lat > poleLowerLatLimit$ \;
    $poleHighIndexS \leftarrow $ find first index where $lat > poleHigherLatLimit$ \;
    $polarGridResolution \leftarrow dx[-poleLowIndexS] $ \Comment*[l]{Will be reused for the north pole}
    $gridSize \leftarrow r \cos(lat[-poleLowIndexS] \frac{\pi}{180})$ \Comment*[l]{Will be reused for the north pole}
    \BlankLine

    $gridXAxisS \leftarrow $ array going from $-gridSize$ to $gridSize$ with steps of $polarGridResolution$ \;
    $gridYAxisS \leftarrow $ array going from $-gridSize$ to $gridSize$ with steps of $polarGridResolution$ \;
    $gridXValuesS, gridYValuesS \leftarrow $ generate the grid from the two axis vectors $gridXAxissS$ and $gridYAxissS$ \;
    $gridSideLength \leftarrow gridXValuesS.length $ \Comment*[l]{Is globally available\dots}
    \BlankLine 

    $gridLatCoordsS \leftarrow $ empty list \;
    $gridLonCoordsS \leftarrow $ empty list \;
    \For{$i \leftarrow 0$ \KwTo $gridXValuesS.length$}{
        \For{$j \leftarrow 0$ \KwTo $gridXValuesS[i].length$}{
            $x \leftarrow gridXValuesS[i, j]$ \;
            $y \leftarrow gridYValuesS[i, j]$ \;
            $latPoint \leftarrow -\arccos(\frac{\sqrt{x^2 + y^2}}{r})\frac{180}{\pi}$ \;
            $lonPoint \leftarrow 180 - \arctan(\frac{x}{y})\frac{180}{\pi}$ \;
            $gridLatCoordsS.append(latPoint)$ \;
            $gridLonCoordsS.append(lonPoint)$ \;
        }
    }

    \BlankLine
    $polarXCoordsS \leftarrow$ empty list \;
    $polarYCoordsS \leftarrow$ empty list \;
    \For{$i \leftarrow 0$ \KwTo $poleLowIndexS$}{
        \For{$j \leftarrow 0$ \KwTo $nlon$}{
            $polarXCoordsS.append(r \cos(lat[i] \frac{\pi}{180}) \sin(lon[j]\frac{\pi}{180}))$ \;
            $polarYCoordsS.append(-r \cos(lat[i] \frac{\pi}{180}) \cos(lon[j]\frac{\pi}{180}))$ \;
        }
    }
\end{algorithm}

To make the process of generating the grid faster, we can vectorise the first for loop as shown in \autoref{alg:polar grid south vectorised}. Here instead of going over each value one by one 
(and because Python is an interpreter based language, the interpreter cannot optimise it out as it does not know what is coming next) we treat everything as a vector or a scalar. By treating the 
arrays as a vector, Python can efficiently (and most likely in parallel) perform the same calculations as it would do by using the classic for loop. We include the \texttt{flatten()} method as 
it forces everything to be a one dimensional array (vector).

\begin{algorithm}[htb]
    \caption{Snippet for generating the grid for polar approximation of the south pole}
    \label{alg:polar grid south vectorised}
    $gridLatCoordsS \leftarrow (-\arccos(\frac{\sqrt{gridXValuesS^2 + gridYValuesS^2}}{r})\frac{180}{\pi}).$\texttt{flatten()} \;
    $gridLonCoordsS \leftarrow (180 - \arctan(\frac{gridXValuesS}{gridYValuesS})\frac{180}{\pi}).$\texttt{flatten()} \;
\end{algorithm}

We need to do a similar thing for the north pole and insert a few changes to some of the equations to correct for different angles and similar things. The code can be found in 
\autoref{alg:polar grid north}. Again, see the references at the south pole explanation on how to generate the grid itself.

\begin{algorithm}[htb]
    \caption{Generating the grid for polar approximation of the north pole}
    \label{alg:polar grid north}
    \SetKwComment{Comment}{//}{}
    $poleLowIndexN \leftarrow $ find last index where $lat < -poleLowerLatLimit$ \;
    $poleHighIndexN \leftarrow $ find last index where $lat < -poleHigherLatLimit$ \;
    \BlankLine

    $gridXAxisN \leftarrow $ array going from $-gridSize$ to $gridSize$ with steps of $polarGridResolution$ \;
    $gridYAxisN \leftarrow $ array going from $-gridSize$ to $gridSize$ with steps of $polarGridResolution$ \;
    $gridXValuesN, gridYValuesN \leftarrow $ generate the grid from the two axis vectors $gridXAxisN$ and $gridYAxisN$ \;
    \BlankLine 
    
    $gridLatCoordsN \leftarrow $ empty list \;
    $gridLonCoordsN \leftarrow $ empty list \;
    \For{$i \leftarrow 0$ \KwTo $gridXValuesN.length$}{
        \For{$j \leftarrow 0$ \KwTo $gridXValuesN[i].length$}{
            $x \leftarrow gridXValuesN[i, j]$ \;
            $y \leftarrow gridYValuesN[i, j]$ \;
            $latPoint \leftarrow \arccos(\frac{\sqrt{x^2 + y^2}}{r})\frac{180}{\pi}$ \;
            $lonPoint \leftarrow 180 - \arctan(\frac{x}{y})\frac{180}{\pi}$ \;
            $gridLatCoordsN.append(latPoint)$ \;
            $gridLonCoordsN.append(lonPoint)$ \;
        }
    }

    \BlankLine
    $polarXCoordsN \leftarrow$ empty list \;
    $polarYCoordsN \leftarrow$ empty list \;
    \For{$i \leftarrow 0$ \KwTo $poleLowIndexN$}{
        \For{$j \leftarrow 0$ \KwTo $nlon$}{
            $polarXCoordsN.append(r \cos(lat[i] \frac{\pi}{180}) \sin(lon[j]\frac{\pi}{180}))$ \;
            $polarYCoordsN.append(-r \cos(lat[i] \frac{\pi}{180}) \cos(lon[j]\frac{\pi}{180}))$ \;
        }
    }
\end{algorithm}

As was the case with the south pole, we can optimise the first for loop by vectorising it. A similar snippet to \autoref{alg:polar grid south vectorised} is the result, though there are small 
changes. These changes can be found in \autoref{alg:polar grid north vectorised}.

\begin{algorithm}[htb]
    \caption{Snippet for generating the grid for polar approximation of the north pole}
    \label{alg:polar grid north vectorised}
    $gridLatCoordsS \leftarrow (\arccos(\frac{\sqrt{gridXValuesN^2 + gridYValuesN^2}}{r})\frac{180}{\pi}).$\texttt{flatten()} \;
    $gridLonCoordsS \leftarrow (180 - \arctan(\frac{gridXValuesN}{gridYValuesN})\frac{180}{\pi}).$\texttt{flatten()} \;
\end{algorithm}

In both algorithms it is important to make a distinction between $gridLatCoords$ and $polarXCoords$ and their respective variants. $gridLatCoords$ are the latitudinal coordinates on the 
$lat, lon$ grid corresponding to the $x$ and $y$ coordinates on the polar grid. Whereas $polarXCoords$ are the $x$ coordinates on the polar grid corresponding to the latitude and longitude on 
the $lat, lon$ grid. Those are different to the $gridXValues$ as they represent the values on the $x$ axis as integers which may or may not directly correspond to the $polarXCoords$. So we need 
a way of mapping the $polarXCoords$ to $gridXValues$ and their respective values and vice versa. This is done in the next section.

\subsection{Switching between grids}
Now that we have defined the polar plane grid, we need code to convert the values from the $lat, lon$ grid to the polar plane grid and vice versa. Let's start with converting to the polar grid. 
We need 2 versions of the algorithm for that. One that converts in 2 dimensions, and one that converts in 3 dimensions. The code for the 2 dimensional case is shown in \autoref{alg:beam up 2d}.
Here we use bivariate spline interpolation \cite{bivariatespline} which is a different form of linear interpolation than discussed in \autoref{sec:interpolation} though the same principle 
applies.

\begin{algorithm}[htb]
    \caption{Converting from $lat, lon$ grid to polar plane grid in 2 dimensions}
    \label{alg:beam up 2d}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Latitude coordinates $lat$, Longitude coordinates $lon$, Values of the $lat, lon$ grid $data$, Length of one axis of the polar grid? $gridSize$, Latitude coordinates on the polar grid 
        $gridLatCoords$, Longitude coordinates on the polar grid $gridLonCoords$}
    \Output{Double array representing the values of the $lat, lon$ grid on the polar grid}
    \SetKwComment{Comment}{//}{}
    $f \leftarrow $ \texttt{BivariateSpline}($lat, lon, data$) \Comment*[l]{Do the interpolation}
    $polarPlane \leftarrow f(gridLatCoords, gridLonCoords).$\texttt{reshape}(($gridSize$, $gridSize$)) \Comment*[l]{Check the values of the interpolation at the specified coordinates and force 
    them to align to the polar grid}
    \Return{$polarPlane$}
\end{algorithm}

The 3 dimensional algorithm is quite similar to the 2 dimensional algorithm, which can be found in \autoref{alg:beam up 3d}

\begin{algorithm}[htb]
    \caption{Converting from $lat, lon$ grid to polar plane grid in 3 dimensions}
    \label{alg:beam up 3d}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Latitude coordinates $lat$, Longitude coordinates $lon$, Values of the $lat, lon$ grid $data$, Length of one axis of the polar grid? $gridSize$, Latitude coordinates on the polar grid 
        $gridLatCoords$, Longitude coordinates on the polar grid $gridLonCoords$}
    \Output{Triple array representing the values of the $lat, lon, layer$ grid on the polar grid}
    \SetKwComment{Comment}{//}{}
    $polarPlane \leftarrow $ 3 Dimensional array where the $1^{\text{st}}$ and $2^{\text{nd}}$ dimensions have length $gridSize$ and the $3^{\text{rd}}$ dimension has length $data[0][0].length$ \;
    \For{$k \leftarrow 0$ \KwTo $data[0][0].length$}{
        $f \leftarrow $ \texttt{BivariateSpline}($lat, lon, data[:, :, k]$) \Comment*[l]{Do the interpolation on this layer}
        $polarPlane[:, :, k] \leftarrow f(gridLatCoords, gridLonCoords).$\texttt{reshape}(($gridSize$, $gridSize$)) \Comment*[l]{Check the values of the interpolation at the specified 
        coordinates and force them to align to the polar grid}
    }
    \Return{$polarPlane$}
\end{algorithm}

Having dealt with converting to the polar grid, we now also need to deal with converting from the polar grid. In contrast to converting to the polar griod, this is only done in 3 dimensions so 
we do not need a 2 dimensional algorithm. How we convert from the polar grid can be found in \autoref{alg:beam down}.

\begin{algorithm}[htb]
    \caption{Converting from the polar plane grid to the $lat, lon$ grid in 3 dimensions}
    \label{alg:beam down}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Longitude coordinates $lon$, Values of the $lat, lon$ grid $data$, Polar $x$ value indices $gridXValues$, Polar $y$ value indices $gridYValues$, Polar $x$ coordinates $polarXCoords$, 
        Polar $y$ coordinates $polarYCoords$}
    \Output{Triple array representing the values of the polar grid on the $lat, lon, layer$ grid}
    \SetKwComment{Comment}{//}{}
    $resample \leftarrow $3 Dimensional array where the $1^{\text{st}}$ dimension has length $\lfloor \frac{polarXCoords}{lon.length} \rfloor$, the $2^{\text{nd}}$ dimension has length 
    $lon.length$ and the $3^{\text{rd}}$ dimension has length $data[0][0].length$ \;
    \For{$k \leftarrow 0$ \KwTo $data[0][0].length$}{
        $f \leftarrow $ \texttt{BivariateSpline})($gridXValues, gridYValues, data[:, :, k]$) \Comment*[l]{Do the interpolation on this layer}
        $resample[:, :, k] \leftarrow f(polarXCoords, polarYCoords).$\texttt{reshape}(($\lfloor \frac{polarXCoords}{lon.length} \rfloor, lon.length$)) \Comment*[l]{Check the values of the 
        interpolation at the specified coordinates and force them to align to the polar grid}
    }
    \Return{$resample$}
\end{algorithm}

\subsection{Gradually Changing Grids}
Now that we can convert between grids we also need a way to do so gradually. Otherwise we would move the hard border we had previously around the poles further down the $lat, lon$ grid. Instead 
we have to do some interpolation between the two grids in order to ensure a smooth transition in the final output, so that there are no hard borders. This interpolation is done in 
\autoref{alg:polar interpolation}, using the linear interpolation technique as discussed in \autoref{sec:interpolation}.

\begin{algorithm}[htb]
    \caption{Gradually transition from the $lat, lon$ grid to the polar grid}
    \label{alg:polar interpolation}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Index when to start using the polar grid $poleLowIndex$, Index when to only use the polar grid $poleHighIndex$, Polar data $polarData$, $lat, lon$ data $sphericalData$}
    \Output{3 Dimensional array representing the values on the polar grid with the part that gradually transitions to the $lat, lon$ grid}
    \SetKwComment{Comment}{//}{}
    $output \leftarrow$ 3 Dimensional array with the exact same structure as $polarData$ \;
    $overlap \leftarrow $ $|poleLowIndex - poleHighIndex|$ \;
    
    \BlankLine
    \uIf(\Comment*[h]{Determine whether we are talking about the north or south pole}){$lat[poleLowIndex] < 0$}{
        \DontPrintSemicolon
        \Comment*[l]{South pole}
        \PrintSemicolon
        \For{$k \leftarrow 0$ \KwTo $output[0][0].length$}{
            \For{$i \leftarrow 0$ \KwTo $poleLowIndex$}{
                \uIf{$i < poleHighIndex$}{
                    $\lambda \leftarrow 0$ \;
                } \uElse{
                    $\lambda \leftarrow \frac{i - poleHighIndex}{overlap}$ \;
                }
                $output[i, :, k] \leftarrow (1 - \lambda) sphericalData[i, :, k] + \lambda polarData[i, :, k]$ \;
            }
        }
    } \uElse{
        \DontPrintSemicolon
        \Comment*[l]{North pole}
        \PrintSemicolon
        \For{$k \leftarrow 0$ \KwTo $output[0][0].length$}{
            \For{$i \leftarrow 0$ \KwTo $nlat - poleLowIndex$}{
                \uIf{$i + poleLowIndex + 1 > poleHighIndex$}{
                    $\lambda \leftarrow 0$ \;
                } \uElse{
                    $\lambda \leftarrow \frac{i}{overlap}$ \;
                }
                $output[i, :, k] \leftarrow (1 - \lambda) sphericalData[i, :, k] + \lambda polarData[i, :, k]$ \;
            }
        }
    }

    \BlankLine
    \Return{$output$}
\end{algorithm}

\subsection{Gradients on the Grid}
With our new found ability to convert to and from the polar grid, while also gradually transitioning, we now get to the part we are doing it all for. Calculations on the polar grid. In order for
that to work, we need some utility functions specifically for the polar grid first. We will need gradients in all 3 dimensions, those being the $x$ dimension, the $y$ dimension and the $p$ 
dimension (pressure). All of the gradients will be quite similar to \autoref{alg:gradient x}, \autoref{alg:gradient y} and \autoref{alg:gradient z} though some small tweaks are required as we 
are not differentiating over a spehere but over a plane. These changes are reflected in \autoref{alg:polar gradient x}, \autoref{alg:polar gradient y} and \autoref{alg:polar gradient p}.

\begin{algorithm}[htb]
    \caption{Gradient in the $x$ dimension on the polar grid}
    \label{alg:polar gradient x}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, first index $i$, second index $j$ and third index $k$, resolution of the polar grid $polarGridResolution$}
    \Output{Gradient in the $x$ dimension for the value of the grid point at the specified coordinates}
    \uIf{$i = 0$}{
        $value \leftarrow \frac{data[i, j + 1, k] - data[i, j, k]}{polarGridResolution}$ \;
    } \uElseIf{$j = gridSideLength - 1$}{
        $value \leftarrow \frac{data[i, j, k] - data[i, j - 1, k]}{polarGridResolution}$ \;
    } \uElse{
        $vale \leftarrow \frac{data[i, j + 1, k] - data[i, j - 1, k]}{2 polarGridResolution}$ \; 
    }
    \Return{$value$}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Gradient in the $y$ dimension on the polar grid}
    \label{alg:polar gradient y}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, first index $i$, second index $j$ and third index $k$, resolution of the polar grid $polarGridResolution$}
    \Output{Gradient in the $y$ dimension for the value of the grid point at the specified coordinates}
    \uIf{$i = 0$}{
        $value \leftarrow \frac{data[i + 1, j, k] - data[i, j, k]}{polarGridResolution}$ \;
    } \uElseIf{$i = gridSideLength - 1$}{
        $value \leftarrow \frac{data[i, j, k] - data[i - 1, j, k]}{polarGridResolution}$ \;
    } \uElse{
        $vale \leftarrow \frac{data[i + 1, j, k] - data[i - 1, j, k]}{2 polarGridResolution}$ \; 
    }
    \Return{$value$}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Gradient in the $p$ dimension on the polar grid}
    \label{alg:polar gradient p}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, first index $i$, second index $j$ and third index $k$, pressure levels $pressureLevels$}
    \Output{Gradient in the $p$ dimension for the value of the grid point at the specified coordinates}
    \uIf{$i = 0$}{
        $value \leftarrow \frac{data[i, j, k + 1] - data[i, j, k]}{pressureLevels[k + 1] - pressureLevels[k]}$ \;
    } \uElseIf{$k = nlevels - 1$}{
        $value \leftarrow \frac{data[i, j, k] - data[i, j, k - 1]}{pressureLevels[k] - pressureLevels[k - 1]}$ \;
    } \uElse{
        $vale \leftarrow \frac{data[i, j, k + 1] - data[i, j, k - 1]}{pressureLevels[k + 1] - pressureLevels[k - 1]}$ \; 
    }
    \Return{$value$}
\end{algorithm}

Now that we have seen the normal versions, let us vectorise them for optimal performance. The vectorised versions do exactly the same, however instead of returning a single value (and the method
needing to be called for each and every element) we return a matrix of gradients. By using a matrix, we can apply the gradient to multiple elements at once and efficiently. The vectorised 
versions can be found in \autoref{alg:polar gradient x vectorised}, \autoref{alg:polar gradient y vectorised} and \autoref{alg:polar gradient p vectorised} respectively.

\begin{algorithm}[htb]
    \caption{Gradient in the $x$ dimension on the polar grid}
    \label{alg:polar gradient x vectorised}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, resolution of the polar grid $polarGridResolution$}
    \Output{Triple array containing the gradients for each cell on the polar grid}
    $shiftEast \leftarrow $ shift all $x$ coordinates in $data$ one cell to the east (positive $x$) \;
    $shiftWest \leftarrow $ shift all $x$ coordinates in $data$ one cell to the west (negative $x$) \;
    \Return{$\frac{shiftWest - shiftEast}{2 polarGridResolution}$}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Gradient in the $y$ dimension on the polar grid}
    \label{alg:polar gradient y vectorised}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, resolution of the polar grid $polarGridResolution$}
    \Output{Triple array containing the gradients for each cell on the polar grid}
    $shiftSouth \leftarrow $ shift all $y$ coordinates in $data$ one cell to the south (negative $y$) \;
    $shiftNorth \leftarrow $ shift all $y$ coordinates in $data$ one cell to the north (positive $y$) \;
    \Return{$\frac{shiftNorth - shiftSouth}{2 polarGridResolution}$}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Gradient in the $p$ dimension on the polar grid}
    \label{alg:polar gradient p vectorised}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Triple array of data $data$, pressure levels $pressureLevels$}
    \Output{Triple array containing the gradients for each cell on the polar grid}
    $shiftUp\leftarrow $ shift all $p$ coordinates in $data$ one cell upwards (positive $p$) \;
    $shiftDown \leftarrow $ shift all $p$ coordinates in $data$ one cell downwards (negative $p$) \;
    $shiftPressureUp \leftarrow$ shift the pressure in $pressureLevels$ up by one cell \;
    $shiftPressureDown \leftarrow$ shift the pressure in $pressureLevels$ down by one cell \;
    \Return{$\frac{shiftDown - shiftUp}{shiftPressureDown - shiftPressureUp}$}
\end{algorithm}

\subsection{Calculating Velocities on the Polar Grid}
With all the utility functions out of the way, we now come to the physics of it. Let us start with the velocity calculations on the polar grid. These work very similarly to the ones on the lat, 
lon grid, though not exactly. For the explanation of the equations, please refer to \autoref{sec:velocity}. The algorithm is given (in its non-vectorised form) in 
\autoref{alg:polar velocity}. An important thing to note is that this algorithm does not calculate the new velocities, but rather what needs to be changed with regards to the velocities. 
The \texttt{gridXGradient} refers to \autoref{alg:polar gradient x} and \texttt{gridYGradient} refers to \autoref{alg:polar gradient y}.

\begin{algorithm}[htb]
    \caption{Velocity calculations on the polar plane}
    \label{alg:polar velocity}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Polar plane $polarPlane$, Length of one axis of the grid $polarGridLength$, Coriolis force on the plane (with the same size and resolution as the $polarPlane$) $coriolisPlane$, 
            East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Resolution of the polar grid $polarGridResolution$}
    \Output{Additions to the east-west velocity vector on the polar plane $\dot{x}_{add}$, Additions to the north-south velocity vector on the polar plane $\dot{y}_{add}$}
    \For{$i \leftarrow 0$ \KwTo $polarGridLength$}{
        \For{$j \leftarrow 0$ \KwTo $polarGridLength$}{
            \For{$k \leftarrow 0$ \KwTo $polarPlane[0, 0].length$}{
                \uIf{$k \geq 17$}{
                    $\dot{x}_{add}[i, j, k] \leftarrow - \dot{x}[i, j, k] \texttt{gridXGradient}(\dot{x}, i, j, k) - \dot{y}[i, j, k] \texttt{gridYGradient}(\dot{x}, i, j, k) +$ 
                    $coriolisPlane[i, j] \dot{y}[i, j, k] - \texttt{gridXGradient}(polarPlane, i, j, k) - \dot{x}[i, j, k] \cdot 10^{-5}$ \;
                    $\dot{y}_{add}[i, j, k] \leftarrow - \dot{x}[i, j, k] \texttt{gridXGradient}(\dot{y}, i, j, k) - \dot{y}[i, j, k] \texttt{gridYGradient}(\dot{y}, i, j, k) -$ 
                    $coriolisPlane[i, j] \dot{x}[i, j, k] - \texttt{gridXGradient}(polarPlane, i, j, k) - \dot{y}[i, j, k] \cdot 10^{-5}$ \;
                } \uElse{
                    $\dot{x}_{add}[i, j, k] \leftarrow - \dot{x}[i, j, k] \texttt{gridXGradient}(\dot{x}, i, j, k) - \dot{y}[i, j, k] \texttt{gridYGradient}(\dot{x}, i, j, k) -$
                    $\dot{x}[i, j, k] \cdot 10^{-3}$ \; 
                    $\dot{y}_{add}[i, j, k] \leftarrow - \dot{x}[i, j, k] \texttt{gridXGradient}(\dot{y}, i, j, k) - \dot{y}[i, j, k] \texttt{gridYGradient}(\dot{y}, i, j, k) -$
                    $\dot{y}[i, j, k] \cdot 10^{-3}$ \; 
                }
                
            }
        }
    }

    \Return{$\dot{x}_{add}, \dot{y}_{add}$}  
\end{algorithm}

One velocity calculation is still missing. That one being the vertical velocity, which is described in \autoref{alg:polar velocity vert}.

\begin{algorithm}[htb]
    \caption{Vertical velocity calculations for the polar plane}
    \label{alg:polar velocity vert}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Pressure levels $pressureLevels$, Temperature on the polar plane 
            $temp$, Resolution of the polar grid $polarGridResolution$}
    \Output{Vertical velocity on the polar plane}
    $output \leftarrow$ array like $\dot{x}$ \;
    \For{$i \leftarrow 0$ \KwTo $output.length$}{
		\For{$j \leftarrow 0$ \KwTo $output[i].length$}{
			\For{$k \leftarrow 0$ \KwTo $output[i, j].length$}{
                $output[i,j,k] = - \frac{(pressureLevels[k] - pressureLevels[k-1]) * pressureLevels[k] * g * (\texttt{gridXGradient}(\dot{x}, i, j, k) + \texttt{gridYGradient}(\dot{y}, i, j, k))}
                    {287 * temp[i, j, k]}$ \;
            }
        }
    }
    \Return{$output$}
\end{algorithm}

Now it is time to optimise (and thus vectorise)! The new versions of the algorithms can be found in \autoref{alg:polar velocity vectorised} and \autoref{alg:polar velocity vert vectorised}. 
Here, \texttt{gridXGradient} refers to \autoref{alg:polar gradient x vectorised} and \texttt{gridYGradient} refers to \autoref{alg:polar gradient y vectorised}.

\begin{algorithm}[htb]
    \caption{Velocity calculations on the polar plane}
    \label{alg:polar velocity vectorised}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Polar plane $polarPlane$, Length of one axis of the grid $polarGridLength$, Coriolis force on the plane (with the same size and resolution as the $polarPlane$) $coriolisPlane$, 
            East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Resolution of the polar grid $polarGridResolution$}
    \Output{Additions to the east-west velocity vector on the polar plane $\dot{x}_{add}$, Additions to the north-south velocity vector on the polar plane $\dot{y}_{add}$}
    $\dot{x}_{add} \leftarrow - \dot{x} \texttt{gridXGradient}(\dot{x}, polarGridResolution) - \dot{y} \texttt{gridYGradient}(\dot{x}, polarGridResolution) + coriolisPlane[:, :, None] \dot{y} -$ 
        $\texttt{gridXGradient}(polarPlane, polarGridResolution) - \dot{x} \cdot 10^{-5}$ \;
    $\dot{y}_{add} \leftarrow - \dot{x} \texttt{gridXGradient}(\dot{y}, polarGridResolution) - \dot{y} \texttt{gridYGradient}(\dot{y}, polarGridResolution) - coriolisPlane[:, :, None] \dot{x} -$ 
        $\texttt{gridXGradient}(polarPlane, polarGridResolution) - \dot{y} \cdot 10^{-5}$ \;

    $\dot{x}_{add}[:,:,17:] \leftarrow - \dot{x}[:,:,17:] \texttt{gridXGradient}(\dot{x}, polarGridResolution) - \dot{y}[:,:,17:] \texttt{gridYGradient}(\dot{x}, polarGridResolution) - $ 
        $\dot{x}[:,:,17:] \cdot 10^{-3}$ \; 
    $\dot{y}_{add}[:,:,17:] \leftarrow - \dot{x}[:,:,17:] \texttt{gridXGradient}(\dot{y}, polarGridResolution) - \dot{y}[:,:,17:] \texttt{gridYGradient}(\dot{y}, polarGridResolution) -$
        $\dot{y}[:,:,17:] \cdot 10^{-3}$ \; 


    \Return{$\dot{x}_{add}, \dot{y}_{add}$}  
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Vertical velocity calculations for the polar plane}
    \label{alg:polar velocity vert vectorised}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Pressure levels $pressureLevels$, Temperature on the polar plane 
            $temp$, Resolution of the polar grid $polarGridResolution$}
    \Output{Vertical velocity on the polar plane}
    $shiftUp \leftarrow$ shift all cells in pressureLevels up by one cell (wrap around if needed) \;
    \Return{$-\frac{(pressureLevels - shiftUp) * pressureLevels * g * (\texttt{gridXGradient}(\dot{x}, polarGridResolution) + \texttt{gridYGradient}(\dot{y}, polarGridResolution))}{287 * temp}$}
\end{algorithm}

\subsection{Projecting the Velocities}
Now that we have methods that can calculate the velocities on the polar plane and on the normal grid, we now need to combine methods to convert from the polar plane to the normal grid and vice 
versa. Due to the polar grid having different axes than the normal grid, we cannot simply project them down and be done with it. We actually need to correct for the differences in axes. After 
projecting the polar plane velocity vectors down as is, we correct for the mismatch in axes by converting everything back to the lat, lon grid. As that grid uses spherical coordinates, we know 
that each pointon that grid is uniquely identified by a combination of the $\sin$ and $\cos$ functions. This fact we use in realigning the velocity vectors. The whole process is shown in 
\autoref{alg:project velocities north} and \autoref{alg:project velocities south}. \texttt{BeamMeDown} refers to \autoref{alg:beam down}. Again, the north and south methods are quite similar. 
Apart from a few different variable names the only real difference is reversing the reprojected vector values along the 2nd dimension for the north polar plane. This has to do with the 
difference in axis alignment between the two polar planes. Now you might be wondering what $[\texttt{None}, :, \texttt{None}]$ means when appended to $lon$. It turns the $lon$ 1-dimensional 
array into a 3-dimensional array. It does this by creating small arrays that contain all a single element. So $lon[\texttt{None}, :, \texttt{None}]$ will become something like: 
$[[[x], [y], \dots]]$ where $x$ and $y$ are elements of the original $lon$.

\begin{algorithm}[htb]
    \caption{Projecting velocities from the northern polar plane down to the normal grid}
    \label{alg:project velocities north}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Longitude coordinates $lon$, East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Lower limit of northern polar plane 
        $poleLowIndexN$, Polar $x$ value indices $gridXValues$, Polar $y$ value indices $gridYValues$, Polar $x$ coordinates $polarXCoords$, Polar $y$ coordinates $polarYCoords$}
    \Output{Reprojected east-west velocity vector on the lat, lon grid $u$, Reprojected north-south velocity vector on the lat, lon grid $v$}
    $repX \leftarrow $ \texttt{BeamMeDown}$(lon, \dot{x}, poleLowIndexN, gridXValues, gridYValues, polarXCoords, polarYCoords)$ \;
    $repY \leftarrow $ \texttt{BeamMeDown}$(lon, \dot{y}, poleLowIndexN, gridXValues, gridYValues, polarXCoords, polarYCoords)$ \;
    $u \leftarrow repX * \sin(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180}) + repY * \cos(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180})$ \;
    $v \leftarrow repX * \cos(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180}) - repY * \sin(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180})$ \;
    $u \leftarrow $ reverse all values of $u$ along the 2nd dimension \;
    $v \leftarrow $ reverse all values of $v$ along the 2nd dimension \;
    \Return{$u, v$}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Projecting velocities from the southern polar plane down to the normal grid}
    \label{alg:project velocities south}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Longitude coordinates $lon$, East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Lower limit of southern polar plane 
        $poleLowIndexS$, Polar $x$ value indices $gridXValues$, Polar $y$ value indices $gridYValues$, Polar $x$ coordinates $polarXCoords$, Polar $y$ coordinates $polarYCoords$}
    \Output{Reprojected east-west velocity vector on the lat, lon grid $u$, Reprojected north-south velocity vector on the lat, lon grid $v$}
    $repX \leftarrow $ \texttt{BeamMeDown}$(lon, \dot{x}, poleLowIndexS, gridXValues, gridYValues, polarXCoords, polarYCoords)$ \;
    $repY \leftarrow $ \texttt{BeamMeDown}$(lon, \dot{y}, poleLowIndexS, gridXValues, gridYValues, polarXCoords, polarYCoords)$ \;
    $u \leftarrow repX * \sin(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180}) + repY * \cos(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180})$ \;
    $v \leftarrow -repX * \cos(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180}) + repY * \sin(lon[\texttt{None}, :, \texttt{None}] * \frac{\pi}{180})$ \;
    \Return{$u, v$}
\end{algorithm}

The previous algorithms show how to convert from the polar plane to the lat, lon grid. However we also need the other direction. That process is shown in \autoref{alg:project velocities up}. We 
use similar information to re-align the velocity vectors to the polar plane grid as we used to re-align the velocity vectors to the lat, lon grid. \texttt{BeamMeUp} corresponds to the 
\autoref{alg:beam up 3d}.

\begin{algorithm}[htb]
    \caption{Projecting velocities from the normal grid to the polar plane}
    \label{alg:project velocities up}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Latitude coordinates $lat$, Longitude coordinates $lon$, East-west velocity vector $u$, North-south velocity vector $v$, Size of the polar grid $gridSize$, Latitude coordinates 
        corresponding to the polar plane grid $gridLatCoords$, Longitude coordinates correpsonding to the polar plane grid $gridLonCoords$}
    \Output{East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar planes $\dot{y}$}
    \SetKwComment{Comment}{//}{}
    $gridU \leftarrow $ \texttt{BeamMeUp}$(lat, lon, u, gridSize, gridLatCoords, gridLonCoords)$ \;
    $gridV \leftarrow $ \texttt{BeamMeUp}$(lat, lon, v, gridSize, gridLatCoords, gridLonCoords)$ \;

    $nlevels \leftarrow u[0, 0].length$ \Comment*[r]{Does not replace the global, is only of effect here in this method}

    $\dot{x} \leftarrow$ matrix with shape $gridSize \times gridSize \times nlevels$ \;
    $\dot{y} \leftarrow$ matrix with shape $gridSize \times gridSize \times nlevels$ \;

    $gridLonCoords \leftarrow gridLonCoords.\texttt{reshape}(gridSize, gridSize)$ \;

    \uIf(//Check to see with which pole we are dealing){$lat[0] < 0$}{
        \For{$k \leftarrow 0$ \KwTo $nlevels - 1$}{
            $\dot{x}[:, :, k] \leftarrow gridU[:, :, k] * \sin(gridLonCoords * \frac{\pi}{180}) - gridV[:, :, k] * \cos(gridLonCoords * \frac{\pi}{180})$ \;
            $\dot{y}[:, :, k] \leftarrow gridU[:, :, k] * \cos(gridLonCoords * \frac{\pi}{180}) + gridV[:, :, k] * \sin(gridLonCoords * \frac{\pi}{180})$ \;
        }
    } \uElse {
        \For{$k \leftarrow 0$ \KwTo $nlevels - 1$}{
            $\dot{x}[:, :, k] \leftarrow -gridU[:, :, k] * \sin(gridLonCoords * \frac{\pi}{180}) + gridV[:, :, k] * \cos(gridLonCoords * \frac{\pi}{180})$ \;
            $\dot{y}[:, :, k] \leftarrow -gridU[:, :, k] * \cos(gridLonCoords * \frac{\pi}{180}) - gridV[:, :, k] * \sin(gridLonCoords * \frac{\pi}{180})$ \;
        }
    }
    \Return{$\dot{x}, \dot{y}$}
\end{algorithm}

\subsection{Advection on the Polar Planes}
Like we have done with the velocities, we also need to make a calculation for the advection on the polar planes themselves. We do this in \autoref{alg:polar advection}. For more details about 
advection itself, please refer to \autoref{sec:adv}. The interesting bit of magic happens with the $\dot{y}[i, j, :] + |\dot{y}[i, j, :]|$ term. If $\dot{y}[i, j, :]$ is negative, then this 
whole term will be $0$ and hence will not be considered, whereas if it is positive it will be considered (that's also why we divide by $2 * polarGridResolution$, to correct for adding 
$\dot{y}[i, j, :]$ twice). Doing it this way saves an if statement and allows everything to be calculated faster along the last dimension. We have also added specific assignments for $j = 0$ and 
for $j = \dot{x}[i].length$ as these indicate the boundaries of the $\dot{x}$ vector and saves us 2 more if statements.

\begin{algorithm}[htb]
    \caption{Performing the advection calculations on the polar plane}
    \label{alg:polar advection}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \Input{Data matrix $data$, East-west velocity vector on the polar plane $\dot{x}$, North-south velocity vector on the polar plane $\dot{y}$, Resolution of the polar grid $polarGridResolution$}
    \Output{3-dimensional matrix with the advection data on the polar plane $adv$}
    $adv \leftarrow $ matrix with the same size as $data$ \;
    \For{$i \leftarrow 1$ \KwTo $\dot{x}.length - 1$}{
        $j \leftarrow 0$ \;
        $adv[i, j, :] \leftarrow adv + \frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i, j, :] - data[i - 1, j, :])}{2 * polarGridResolution} +$ 
        $\frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i + 1, j, :] - data[i, j, :])}{2 * polarGridResolution}$ \;
        $adv[i, j, :] \leftarrow adv + \frac{(\dot{x}[i, j, :] + |\dot{x}[i, j, :]|) * (data[i, j + 1, :] - data[i, j, :])}{2 * polarGridResolution}$ \;

        \For{$j \leftarrow 1$ \KwTo $\dot{x}[i].length - 1$}{
            $adv[i, j, :] \leftarrow adv + \frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i, j, :] - data[i - 1, j, :])}{2 * polarGridResolution} +$ 
            $\frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i + 1, j, :] - data[i, j, :])}{2 * polarGridResolution}$ \;
            $adv[i, j, :] \leftarrow adv + \frac{(\dot{x}[i, j, :] + |\dot{x}[i, j, :]|) * (data[i, j, :] - data[i, j - 1, :])}{2 * polarGridResolution} + $
            $\frac{(\dot{x}[i, j, :] + |\dot{x}[i, j, :]|) * (data[i, j + 1, :] - data[i, j, :])}{2 * polarGridResolution}$ \;
        }

        $j \leftarrow \dot{x}[i].length - 1$ \;
        $adv[i, j, :] \leftarrow adv + \frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i, j, :] - data[i - 1, j, :])}{2 * polarGridResolution} +$ 
        $\frac{(\dot{y}[i, j, :] + |\dot{y}[i, j, :]|) * (data[i + 1, j, :] - data[i, j, :])}{2 * polarGridResolution}$ \;
        $adv[i, j, :] \leftarrow adv + \frac{(\dot{x}[i, j, :] + |\dot{x}[i, j, :]|) * (data[i, j, :] - data[i, j - 1, :])}{2 * polarGridResolution}$ \;
    }
    \Return{$adv$}
\end{algorithm}